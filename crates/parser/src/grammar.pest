// piptable grammar
// Combines VBA-like syntax with SQL

// =============================================================================
// Whitespace and Comments
// =============================================================================

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "'" ~ (!"\n" ~ ANY)* }

// =============================================================================
// Program Structure
// =============================================================================

program = { SOI ~ statement* ~ EOI }

statement = {
    dim_stmt
  | if_stmt
  | for_each_stmt
  | for_stmt
  | while_stmt
  | function_def
  | sub_def
  | return_stmt
  | call_stmt
  | chart_stmt
  | export_stmt
  | import_stmt
  | assignment_stmt
  | expr_stmt
}

// =============================================================================
// VBA Statements
// =============================================================================

dim_stmt = { "dim" ~ ident ~ type_hint? ~ "=" ~ expr }
type_hint = { ":" ~ type_name }

assignment_stmt = { lvalue ~ "=" ~ expr }
lvalue = { ident ~ (field_access | array_index)* }

if_stmt = {
    "if" ~ expr ~ "then" ~
    (!("else" | "elseif" | "end") ~ statement)* ~
    elseif_clause* ~
    else_clause? ~
    "end" ~ "if"
}
elseif_clause = { "elseif" ~ expr ~ "then" ~ (!("else" | "elseif" | "end") ~ statement)* }
else_clause = { "else" ~ (!("end") ~ statement)* }

for_each_stmt = {
    ^"for" ~ ^"each" ~ ident ~ ^"in" ~ expr ~
    (!(^"next") ~ statement)* ~
    ^"next" ~ ident?
}

for_stmt = {
    ^"for" ~ ident ~ "=" ~ expr ~ ^"to" ~ expr ~ step_clause? ~
    (!(^"next") ~ statement)* ~
    ^"next" ~ ident?
}
step_clause = { "step" ~ expr }

while_stmt = { "while" ~ expr ~ (!("wend") ~ statement)* ~ "wend" }

function_def = {
    "async"? ~ "function" ~ ident ~ "(" ~ param_list? ~ ")" ~
    (!("end") ~ statement)* ~
    "end" ~ "function"
}

sub_def = {
    "async"? ~ "sub" ~ ident ~ "(" ~ param_list? ~ ")" ~
    (!("end") ~ statement)* ~
    "end" ~ "sub"
}

param_list = { ident ~ ("," ~ ident)* }

return_stmt = { "return" ~ expr? }

call_stmt = { "call"? ~ ident ~ "(" ~ arg_list? ~ ")" }

chart_stmt = {
    "chart" ~ chart_type ~ string ~
    chart_option* ~
    "end" ~ "chart"
}
chart_type = { "bar" | "line" | "pie" | "scatter" | "area" }
chart_option = { ident ~ ":" ~ expr }

export_stmt = { "export" ~ expr ~ "to" ~ expr ~ with_clause? }
import_stmt = { "import" ~ file_list ~ sheet_clause? ~ "into" ~ ident ~ import_options? }
file_list = { expr ~ ("," ~ expr)* }
sheet_clause = { "sheet" ~ expr }
import_options = { without_headers | named_params }
without_headers = { "without" ~ "headers" }
named_params = { "(" ~ named_param ~ ("," ~ named_param)* ~ ")" }
named_param = { ident ~ "=" ~ expr }
with_clause = { "with" ~ object_literal }

expr_stmt = { expr }

// =============================================================================
// Expressions
// =============================================================================

expr = { or_expr }
// Word boundaries are enforced by requiring non-alpha after the keyword
// Must be atomic (@) to prevent automatic whitespace insertion before the lookahead
or_kw = @{ ^"or" ~ !ASCII_ALPHA }
and_kw = @{ ^"and" ~ !ASCII_ALPHA }
not_kw = @{ ^"not" ~ !ASCII_ALPHA }
or_expr = { and_expr ~ (or_kw ~ and_expr)* }
and_expr = { not_expr ~ (and_kw ~ not_expr)* }
not_expr = { not_kw? ~ comparison_expr }
comparison_expr = { additive_expr ~ (is_null_check | (comparison_op ~ additive_expr))? }
is_null_check = { ^"is" ~ ^"not"? ~ ^"null" }
in_kw = @{ ^"in" ~ !ASCII_ALPHA }
like_kw = @{ ^"like" ~ !ASCII_ALPHA }
comparison_op = { "==" | "!=" | "<>" | "<=" | ">=" | "<" | ">" | "=" | like_kw | in_kw }
additive_expr = { multiplicative_expr ~ (add_op ~ multiplicative_expr)* }
add_op = { "+" | "-" }
multiplicative_expr = { unary_expr ~ (mul_op ~ unary_expr)* }
mul_op = { "*" | "/" | "%" }
unary_expr = { unary_op? ~ postfix_expr }
unary_op = { "-" | "+" }
postfix_expr = { primary_expr ~ (field_access | array_index | type_assertion | call_args)* }

field_access = { ("->" | ".") ~ ident }
array_index = { "[" ~ expr ~ "]" }
type_assertion = { "::" ~ type_name }
call_args = { "(" ~ arg_list? ~ ")" }

primary_expr = {
    literal
  | query_expr
  | fetch_expr
  | ask_expr
  | async_for_expr
  | parallel_expr
  | await_expr
  | array_literal
  | object_literal
  | "(" ~ expr ~ ")"
  | ident
}

// =============================================================================
// Literals
// =============================================================================

literal = {
    null
  | boolean
  | float
  | integer
  | string
  | interval
}

null = { "null" | "NULL" }
boolean = { "true" | "false" | "TRUE" | "FALSE" }
integer = @{ "-"? ~ ASCII_DIGIT+ }
float = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
string = @{ "\"" ~ string_content* ~ "\"" }
string_content = @{ escape_seq | (!("\"" | "\\") ~ ANY) }
escape_seq = @{ "\\" ~ ("\"" | "\\" | "/" | "n" | "r" | "t" | "b" | "f" | unicode_escape) }
unicode_escape = @{ "u" ~ ASCII_HEX_DIGIT{4} }
interval = { ^"interval" ~ integer ~ interval_unit }
interval_unit = { ^"millisecond" | ^"second" | ^"minute" | ^"hour" | ^"day" | ^"week" | ^"month" | ^"year" | ^"milliseconds" | ^"seconds" | ^"minutes" | ^"hours" | ^"days" | ^"weeks" | ^"months" | ^"years" }

array_literal = { "[" ~ (expr ~ ("," ~ expr)*)? ~ "]" }
object_literal = { "{" ~ (object_field ~ ("," ~ object_field)*)? ~ "}" }
object_field = { (ident | string) ~ ":" ~ expr }

// =============================================================================
// Special Expressions
// =============================================================================

query_expr = { "query" ~ "(" ~ sql_query ~ ")" }
fetch_expr = { "fetch" ~ "(" ~ expr ~ ("," ~ expr)? ~ ")" }
ask_expr = { "ask" ~ string ~ "from" ~ expr ~ (^"using" ~ (^"model")? ~ string)? }
async_for_expr = { "async" ~ "for" ~ "each" ~ ident ~ "in" ~ expr ~ statement* ~ "end" ~ "async" }
parallel_expr = { "parallel" ~ expr ~ ("," ~ expr)* ~ "end" ~ "parallel" }
await_expr = { "await" ~ expr }

// =============================================================================
// SQL Query
// =============================================================================

sql_query = {
    with_clause_sql? ~
    select_clause ~
    from_clause? ~
    join_clause* ~
    where_clause? ~
    group_by_clause? ~
    having_clause? ~
    order_by_clause? ~
    limit_clause? ~
    trigger_clause?
}

with_clause_sql = { ^"with" ~ ^"recursive"? ~ cte ~ ("," ~ cte)* }
cte = { ident ~ ("(" ~ ident ~ ("," ~ ident)* ~ ")")? ~ ^"as" ~ "(" ~ sql_query ~ ")" }

select_clause = { ^"select" ~ distinct_kw? ~ select_list }
distinct_kw = { ^"distinct" }
select_list = { "*" | (select_item ~ ("," ~ select_item)*) }
select_item = { expr ~ (^"as" ~ ident)? }

from_clause = { ^"from" ~ table_ref ~ (^"as" ~ ident | alias_ident)? }
table_ref = {
    table_function
  | qualified_name
  | string
  | ^"stdin"
  | "(" ~ sql_query ~ ")"
}
qualified_name = { ident ~ ("." ~ ident)* }
table_function = { ident ~ "(" ~ func_arg_list? ~ ")" }
func_arg_list = { func_arg ~ ("," ~ func_arg)* }
func_arg = { (ident ~ "=>")? ~ expr }

join_clause = { join_type? ~ ^"join" ~ table_ref ~ (^"as" ~ ident | alias_ident)? ~ (^"on" ~ expr)? }
join_type = { ^"inner" | ^"left" ~ ^"outer"? | ^"right" ~ ^"outer"? | ^"cross" }

where_clause = { ^"where" ~ expr }
group_by_clause = { ^"group" ~ ^"by" ~ expr ~ ("," ~ expr)* }
having_clause = { ^"having" ~ expr }
order_by_clause = { ^"order" ~ ^"by" ~ order_item ~ ("," ~ order_item)* }
order_item = { expr ~ sort_direction? }
sort_direction = { ^"asc" | ^"desc" }
limit_clause = { ^"limit" ~ expr ~ (^"offset" ~ expr)? }
trigger_clause = { ^"trigger" ~ (^"counting" ~ integer | ^"on" ~ ^"watermark" | ^"on" ~ ^"end" ~ ^"of" ~ ^"stream") }

// =============================================================================
// Identifiers and Types
// =============================================================================

// SQL keywords that should not be parsed as identifiers in certain contexts
sql_keyword = _{
    (^"select" | ^"from" | ^"where" | ^"order" | ^"group" | ^"having" | ^"limit" | ^"offset" |
     ^"join" | ^"inner" | ^"left" | ^"right" | ^"cross" | ^"on" | ^"as" |
     ^"and" | ^"or" | ^"not" | ^"null" | ^"is" |
     ^"asc" | ^"desc" | ^"distinct" | ^"with" | ^"recursive" |
     ^"trigger" | ^"counting" | ^"watermark" | ^"stream" | ^"stdin" |
     ^"true" | ^"false" | ^"by" | ^"outer") ~ !(ASCII_ALPHANUMERIC | "_")
}

// Regular identifier (can match keywords - used in most contexts)
ident = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// Non-keyword identifier (for table aliases where keywords should not match)
alias_ident = @{ !sql_keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

type_name = { ^"int" | ^"float" | ^"string" | ^"bool" | ^"timestamp" | ^"duration" | ^"array" | ^"object" | ^"table" }

// =============================================================================
// Arguments
// =============================================================================

arg_list = { expr ~ ("," ~ expr)* }
